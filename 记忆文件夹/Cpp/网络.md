# 第一章 TCP 半关闭

tcp是双通道的，一个通道用来读，一个通道用来写。close 函数 关闭两个通道，shutdown 可以只关闭一个通道



shutdown

```c
int shutdown(int sock, int howto)
    
SHUT_RD		:断开输入流
SHUT_WR		:断开输出流
SHUT_RDWR	:同时断开I/O
```



[参考连接](https://blog.codingnow.com/2021/02/skynet_tcp_halfclose.html)

read 返回值为0，表示读取通道关闭；write 返回-1，错误时epipe，表示写入通道关闭



半关闭的场景

***

> 浏览器从web server 请求资源时，发起http请求，然后关闭write但是保留read。如果web server 读取到 0 时，直接close 连接，就没办法回应包了



> stunnel 协议也需要考虑到这一点



> 文件传输，服务器将文件传输到客户端，文件传输结束后，客户端发送Thank You 给服务端。服务端文件传输结束后，关闭写入通道，客户端read 收到0，然后写入Thank you， 服务端收到Thank you 后，再关闭读取通道。



验证代码

***



client

```cpp
#include <WinSock2.h>
#include <iostream>
using namespace std;
#pragma comment(lib, "ws2_32.lib")

const char* IP = "172.18.80.183";
unsigned short PORT = 5670;
int main(int argc, char* argv[])
{
	int szClntAddr = 0;
	WSADATA wsaData;
	int ret = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (ret != 0) {
		printf("WSAStartup error! \n");
		return -1;
	}

	SOCKET client;
	client = socket(PF_INET, SOCK_STREAM, 0);
	if (client == INVALID_SOCKET) {
		printf("socket error! \n");
		return -2;
	}

	SOCKADDR_IN serverAddr;
	memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = inet_addr(IP);
	serverAddr.sin_port = htons(PORT);

	ret = connect(client, (SOCKADDR*)&serverAddr, sizeof(serverAddr));
	if (ret == SOCKET_ERROR) {
		printf("connect error! \n");
		return -3;
	}

	char message[1024] = { 0 };
	// 返回值 >0		表示收到的字节数
	// 返回值 =0		表示对端关闭 写入,本端关闭读取  ; TCP 是全双工的,因此 此时依旧可能会  本端可以写入,对端能读取
	// 返回值 =-1	表示出错
	int strLen = recv(client, message, sizeof(message) - 1, 0);
	if (strLen == -1) {
		printf("recv error! \n");
		return -3;
	}

	// 半关闭后依旧可以写入数据 
	while (true)
	{
		// 发送数据
		char buf[] = "Hello World!";
		// 返回值 >0		表示发送的字节数
		// 返回值 =-1	表示出错
		// 如果对端已经关闭,而本端未关闭,连续两次send 会触发信号SIGPIPE
		int strLen = send(client, buf, sizeof(buf) - 1, 0);
		if (strLen == -1) {
			printf("recv error! \n");
			return -3;
		}
		Sleep(1000);
	}

	closesocket(client);
	WSACleanup();
	return 0;
}
```



server

```cpp
#include <WinSock2.h>
#include <iostream>
using namespace std;
#pragma comment(lib, "ws2_32.lib")

unsigned short PORT = 5670;
int main(int argc, char* argv[]) 
{
	int szClntAddr = 0;
	int ret;

	WSADATA wsaData;
	ret = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (ret != 0) {
		printf("WSAStartup error! \n");
		return -1;
	}

	SOCKET client;
	SOCKET server;
	server = socket(PF_INET, SOCK_STREAM, 0);
	if (server == INVALID_SOCKET) {
		printf("socket error! \n");
		return -2;
	}

	SOCKADDR_IN serverAddr;
	SOCKADDR_IN clientAddr;
	memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serverAddr.sin_port = htons(PORT);

	ret = bind(server, (SOCKADDR*)&serverAddr, sizeof(serverAddr));
	if (ret == SOCKET_ERROR) {
		printf("connect error! \n");
		return -3;
	}

	ret = listen(server, 5);
	if (ret == SOCKET_ERROR) {
		printf("listen error! \n");
		return -4;
	}

	szClntAddr = sizeof(clientAddr);
	for (;;) {
		client = accept(server, (SOCKADDR*)&clientAddr, &szClntAddr);
		if (client == INVALID_SOCKET) {
			printf("accept error! \n");
			return -5; 
		} 

		shutdown(client, SD_SEND); // 关闭输出流,对方read 收到EOF 

		char message[1024] = { 0 };
		//recv 成功返回收到的字节数 0表示对方关闭了socket <0 出错
		while (true)
		{
			int strLen = recv(client, message, sizeof(message) - 1, 0);
			if (strLen < 0) {
				printf("recv error! \n");
				return -3;
			}
			if (strLen == 0) {
				cout << "EOF " << endl;
				return -2;
			}

			message[strLen] = '\0';
			cout << "recv : " << message << endl;

			{
				char buf[] = "Hello World!";
				// 返回值 >0		表示发送的字节数
				// 返回值 =-1	表示出错
				// 如果对端已经关闭,而本端未关闭,连续两次send 会触发信号SIGPIPE
				int strLen = send(client, buf, sizeof(buf) - 1, 0);
				if (strLen == -1) {
					printf("recv error! \n");
					return -3;
				}
			}
		}
	}
	WSACleanup();
	return 0;
}
```





疑问：<b style="color:red">read 返回值为0时，可能是半关闭也可能全关闭，如何区分</b>





# 第二章 unix 域套接字

1. 代码

   ```cpp
   #include <stdio.h>
   #include <string.h>
   #include <sys/types.h>
   #include <sys/socket.h>
   #include <sys/un.h>
   #include<unistd.h>
   #include<pthread.h>
    
    
    // 测试: nc -U ./sample-socket  -- 使用nc 可以直接连接上去
    // 编译命令: gcc server.c -o server -lpthread
   /* issue an error message via perror() and terminate the program */
   void PrintfError(char * message)
   {
       perror(message);
       // exit(1);
   }
    
    static void*  handler(void *arg)       
    {
   	 int sock = (int)arg;
   	 char message[1024] = {0};
   	 while(1){
   		 int n = read(sock, message, sizeof(message)-1);
   		 if(n == -1){
   			 // 出错
   			 printf("read error!\n");
   			 break;
   		 }else if(n == 0){
   			 // EOF
   			 printf("EOF \n");
   			 break;
   		 }else if(n > 0){
   			printf("recv : %s \n", message);
   		 }
   		 n = write(sock, message, n);
   		 if(n == -1){
   			printf("write error!\n");
   			 break;
   		 }
   	 }
        return NULL;
    }
   int main(void) {
       struct sockaddr_un address;	// #include <sys/un.h>
       int sock, conn;
       socklen_t addrLength;
    
   	// AF 表示ADDRESS FAMILY 地址族 
   	// PF 表示PROTOCL FAMILY 协议族
       if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {
           PrintfError("socket");
   	}
    
       /* Remove any preexisting socket (or other file) */
       unlink("./sample-socket");
    
       address.sun_family = AF_UNIX;       /* Unix domain socket */
       strcpy(address.sun_path, "./sample-socket");
    
       /* The total length of the address includes the sun_family element */
       addrLength = sizeof(address.sun_family) + strlen(address.sun_path);
    
       if (bind(sock, (struct sockaddr *)&address, addrLength)) {
           PrintfError("bind");
   	}
    
       if (listen(sock, 5)) {
           PrintfError("listen");
   	}
    
       while ((conn = accept(sock, (struct sockaddr *)&address, &addrLength)) >= 0) {
   		pthread_t tidp;
   		if ((pthread_create(&tidp, NULL, &handler, (void*)conn)) == -1)
   		 {
   			 printf("create error!\n");
   			return 1;
   		 }
       }
    
       if (conn < 0) {
           PrintfError("accept");
   	}
      
       close(sock);
       return 0;
   }
   
   ```

2. 测试

   ```shell
   nc -U ./sample-socket
   ```

3. Boost 实现Unix Socket client

   ```c++
   		boost::asio::io_context io_context;
   		stream_protocol::socket s(io_context);
   		std::string host = Utility::pathJoin(Config::get_const_instance().Node.runtimeDir, name, "qga.sock");
   		s.connect(stream_protocol::endpoint(host));
   		
   		std::string cmd = boost::algorithm::join(cmds, "\n") + "\n";
   		boost::asio::write(s, boost::asio::buffer(cmd, cmd.size()));
   
   		std::string data(4096, '\0');
   		boost::system::error_code error;
   		size_t reply_length = s.read_some(boost::asio::buffer(data), error);// TODO 这里也要加上while 循环,否则可能出现结果读取不全的情况
   		if (reply_length > 0) {
   			data.resize(reply_length);
   			std::vector<std::string> lines;
   			boost::split(lines, data, boost::is_any_of("\n"));
   			for (auto& line : lines) {
   				if (line.empty()) {
   					continue;
   				}
   				boost::json::error_code  ec;
   				boost::json::value jv = boost::json::parse(line, ec);
   				if (ec) // 检查JSON 解析是否失败
   					{
   						std::cout << "Parsing failed: " << ec.message() << "\n";
   						continue;
   					}
   				boost::json::object obj = jv.as_object();
   				
   				boost::json::value ret = obj["return"];
   				boost::json::value error = obj["error"];
   				if (!ret.is_null()) {
   					std::string entity = boost::json::serialize(ret);
   					replies.push_back(entity);
   				}
   				else if (!error.is_null()) {
   					replies.push_back(line);
   				}
   				else {
   					std::cerr << "[CloudNode] unknown result : " << line << std::endl;
   				}
   				
   				if (replies.size() == cmds.size()) {
   					return replies;
   				}
   			}
   		}
   ```

   





# 第三章 超时



## 3.1 connect 超时

1. 随便找一台ping 不通的主机，connect 过去，会返回10060的错误（机器不存在），此时会阻塞很久
2. 找一台能ping通的机器，开启防火墙，connnect会阻塞很久。
3. 找一台能ping通，但是未监听指定端口的机器，此时会返回10061的错误，目标机器主动拒绝



## 3.2 read 超时





## 3.3 write 超时



## 3.4 accept 超时





## 3.5 keepalive

tcp协议本身自带心跳机制，默认开关是关闭的。



内核参数查看

```shell
sudo sysctl -a | grep keepalive
```



配置参数

```shell
cat <<EOF >>/etc/sysctl.conf

net.ipv4.ip_forward = 1
net.ipv4.tcp_keepalive_intvl = 7
net.ipv4.tcp_keepalive_probes = 2
net.ipv4.tcp_keepalive_time = 10

EOF

sysctl -p
```

程序中开启

```cpp
int keepAlive = 1; // 开启keepalive属性
int keepIdle = 10; // 如该连接在1800秒内没有任何数据往来,则进行探测
int keepInterval = 7; // 探测时发包的时间间隔为3秒
int keepCount = 2; // 探测尝试的次数.如果第1次探测包就收到响应了,则后几次的不再发.
setsockopt(client_fd, SOL_SOCKET, SO_KEEPALIVE, (void*)&keepAlive, sizeof(keepAlive));
setsockopt(client_fd, SOL_TCP, TCP_KEEPIDLE, (void *)&keepIdle, sizeof(keepIdle));
setsockopt(client_fd, SOL_TCP,TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval));
setsockopt(client_fd, SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount));


// 以下是python的demo
import socket

ServerSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ServerSocket.bind((socket.gethostname(), 4224))
ServerSocket.listen(0)
ConnectionSocket, address = ServerSocket.accept()


ConnectionSocket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE,1)
ConnectionSocket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 1)
ConnectionSocket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 3)
ConnectionSocket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 5)
```

iptables模拟断网情况

```shell
iptables -A INPUT -p tcp --dport 5670 -j DROP

# 客户端 telnet + wireshark

# 服务端：自己用Cpp实现代码
```







# 第四章 优化



## 4.1 程序可打开最大文件描述符

```shell
# 查看
ulimit -n

# 设定  只对当前shell有效
ulimit -HSn 65536

# 永久
vi /etc/security/limits.conf
* hard nofile 65536
* soft nofile 65536

## 程序打开超过1024个fd时，accept返回值为-1，错误信息是too many openfile
```



## 4.2 TIME_WAIT过多处理

```shell
#系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
net.ipv4.tcp_max_tw_buckets = 5000 

# 重用time_wait
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_timestamps = 1

# 对公网提供服务的网关不能用，同一个局域网的内部RPC调用可以使用
net.ipv4.tcp_tw_recycle = 1
```

