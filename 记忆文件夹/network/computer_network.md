## 1 TCP的特点

***



### 1 编号系统

***

+ 字节号

  ```shell
  0~(2^32 - 1)之间的一个随机数作为第一个字节的编号
  ```

+ 序号

  ```shell
  每个报文段的序号就是该报文段中第一个数据字节的序号
  ```

+ 确认号

  ```shell
  期望收到的下一个字节的编号
  ```

### 2 流量控制

***

+ 接收方要对发送tcp能够发送多少数据进行控制
+ 发送方要对能够接受多少用户进程传来的数据进行控制

### 3 差错控制

***

+ 报文可能会出错
+ 报文可能会丢失
+ 报文可能会受损

### 4 拥塞控制

***

+ tcp要考虑到网络的拥塞程度





## 2 报文段

***



### 1 格式

***

1. 格式定义

   ```c
   class TCPHeader
   {
       unsigned short  src_port;   // 源端口
       unsigned short  dst_port;   // 目的端口
       unsigned int    seq_num;    // 序号
       unsigned int    ack_num;    // 确认号
       unsigned int:4  hlen;       // 首部长度，指示tcpheader的大小
                int:6  reserved;   // 保留
                int:1  urg;        // 紧急指针有效
                int:1  ack;        // 确认是有效的
                int:1  psh;        // 请求推送
                int:1  rst;        // 连接复位
                int:1  syn;        // 同步序号
                int:1  fin;        // 终止连接
       unsigned short  rwnd;       // 窗口尺寸
       unsigned short  check_sum;  // 校验和
       unsigned short  urgent_pointer; // 紧急指针
       unsigned char[40] options;      // 选项和填充
   };
   ```

   

### 2 封装

***

```shell
# 1-- 应用层数据

# 2-- tcp首部 + 应用层数据

# 3-- ip首部 + tcp首部 + 应用层数据

# 4-- 帧首部 + ip首部 + tcp首部 + 应用层数据
```





## 2 tcp连接

***



### 1 连接建立

***

+ 三向握手

  ```shell
  # 第一次握手
  seq_num = 8000
  syn = 1
  
  # 第二次握手
  seq_num = 15000
  ack_num = 8001
  syn		  = 1
  ack			= 1
  rwnd	  = 5000
  
  # 第三次握手
  seq_num = 8000
  ack_num = 150001
  ack			= 1
  rwnd		= 10000
  ```

  

+ 同时打开 ==> 两个tcp都向对方发送SYN + ACK报文段

+ SYN洪泛攻击

  1. 原理

     ```
     攻击者向服务器发送大量SYN报文，并伪造源ip地址。服务器向假冒的客户端发送SYN+ACK报文，在等待第三次握手的时间里，大量的资源被占用
     ```

  2. 解决策略

     + 限定在指定时间内的连接请求数
     + 过滤不希望的源地址的数据报
     + 推迟资源分配，直到正式连接请求来源为合法ip

  

### 2 数据传送

***

+ 推送数据==> 客户端希望数据发送给服务器，并立即收到响应

  ```shell
  # 1-- 发送tcp不必等待窗口被填满，马上创建报文并立刻发送
  
  # 2-- 报文的psh字段位1，接收方立即将报文交付给上层应用
  ```

  

+ 紧急数据

  1. 定义==> 部分字节需要对端的应用程序以特殊的方式对待

  2. 处理方式

     ```shell
     # 1-- URG 置1
     
     # 2-- 紧急数据放在报文段最前面
     
     # 3-- 紧急指针定义紧急数据结束的地方
     ```

     

### 3 连接终止

***

+ 半关闭==> 连接的一方停止发送数据，但是仍然可以接受数据

+ 例子==> 客户端发送数据给服务器排序，数据发完后客户端可以半关闭

+ 断开连接过程

  ```shell
  # 1-- 客户端主动断开连接
  fin = 1
  
  # 2-- 服务器确认,客户端收到确认后处于半关闭状态,仍然可以接受数据
  ack = 1
  
  # 3-- 服务器断开连接
  fin = 1
  
  # 4-- 客户端确认
  ack = 1
  ```

  

### 4 连接复位

***

+ 复位==> rst = 1

+ 场景

  1. 拒绝连接请求

     ```
     客户端向一个不存在的端口请求连接，服务器返回rst=1的报文段拒绝请求
     ```

  2. 异常终止连接

     ```shell
     # 有哪种异常情况
     出现了异常情况，希望主动放弃在用的连接。
     ```

     

  3. 终止空闲连接

     ```
     发现对端tcp空闲时间过长，主动发送rst=1的报文终止连接
     ```

     

## 3 状态转换图

***





## 4 窗口

***

+ 发送窗口

  ```shell
  已确认的字节====已发送但未确认====可以发送的字节====不允许发送的字节
  ```

+ 接收窗口

  ```shell
  已被进程拉取====已确认等待进程拉去====允许接收字节====不允许接收字节
  ```

  



## 5 流量控制

***



## 6 差错控制

***



## 7 拥塞控制

***



## 8 计时器

***



## 9 选项

***



## 10 软件包

***

