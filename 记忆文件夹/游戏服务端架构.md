# 第一章 绪论

本文主要收集笔者多年游戏开发中常用的服务器的架构





# 第二章 基于消息队列的服务架构



## 2.1 采用消息队列Rabbitmq

```
connector1

connector2   ------>  Rabbitmq  --------->  Game

connectorN
```

1. Rabbitmq有两个队列，一个队列存放client的请求，一个队列存放Game推送给client的数据

2. connector的数据结构

   ```protobuf
   enum ConnectCMD{
   	NONE	 = 0;
   	OPEN 	 = 1;
   	MESSAGE  = 2;
   	CLOSE    = 3;
   	ERROR    = 4;
   }
   
   
   message ConnectMessage{
   	int32 sID 		= 1;   //每个Connector 启动时都有一个唯一的serverID; 可以RPC某个服务获取
   	int32 cID 		= 2;   // 每个客户端连接都有一个cID
   	ConnectCMD cmd  = 3;
   	bytes 	 data   = 4;
   }
   ```

3. Game 模拟skynet的做法，把全部的服务写到 一个进程里面，每个服务使用一个线程。





## 2.2 采用zeromq

zmq的好处是不需要处理连接的重连、不用管服务启动次序等

1. 架构一：connector收到client数据用PIPE模式 push给 Game； 每个connector都订阅Game的消息，当Game需要主动推送消息给client，利用ZMQ.PUB

   ```
   connector1 PUSH ----->
   
   connector2 PUSH -----> PULL  GAME
   
   connector3 PUSH ----->
   ```

2. 架构二：和架构一相比，有一个专门的push 服务；每个connector多监听一个ZMQ.REP 端口；启动时将地址（sid， url）注册到push服务；push服务收到推送数据请求时，根据sid 发起 ZMQ.REQ 发起请求

   ```
   
                                   PUSH-SERVER
   
   connector1 PUSH ----->
   
   connector2 PUSH -----> PULL  GAME
   
   connector3 PUSH ----->
   ```

   

3. 架构三：采用zeromq，只能单个connector [最简单]

   ```shell
   connector PUSH -----> PULL  GAME
         
             PULL <----- PUSH  GAME 
   ```

   





## 2.4 服务划分为有状态和无状态

```

client ---- http ------>  无状态服务

                   connector1
                                 ws/zmq
client   ---->     connector2   -------->  有状态服务,比如玩法
               
                   connector3
```







# 第三章 基于http的协议

这种解决方案的有点在于简单



1. 客户端通过http协议请求服务器数据，服务端有一个专门的推送服务，每个客户端和推送服务建立长连接
2. 客户端和服务器采用json格式通信，服务端推送给客户端的数据也是json
3. token的时间可以设置为1个月或者永远