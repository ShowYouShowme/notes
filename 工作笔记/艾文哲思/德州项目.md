dataproxy：redis缓存代理

dbagent：MySQL数据库代理



vscode项目配置：

```
{
    "configurations": [
        {
            "name": "Win32",
            "includePath": [
                "${workspaceFolder}/**",
                "C:\\\\usr\\\\include",
                "C:\\\\usr\\\\include\\\\x86_64-linux-gnu",
                "..\\comm",
                "../../include/",
                "../../include/rpc",
                "../../include/wbl-0.7"
            ],
            "defines": [
                "_DEBUG",
                "UNICODE",
                "_UNICODE",
                "__x86_64__",
                "__LP64__"
            ],
            "windowsSdkVersion": "10.0.14393.0",
            "compilerPath": "C:/MinGW/bin/g++.exe",
            "cStandard": "c11",
            "cppStandard": "c++17",
            "intelliSenseMode": "gcc-x64"
        }
    ],
    "version": 4
}
```





# 添加数据库

1. 在`util/ServiceDefine.h`里面添加字段

2. 修改`dataproxyserver/config/relative.conf`

   21. 在redis_struct标签里面添加Item

       ```xml
       <40>
       data_type = 1
       section_factor = 1
       ttl = 0
       table = tb_friend
       relative = 0
       key_field = uid
       key_field_type = 0
       join_fields =
       join_fields_type = 
       </40>
       ```

   22. 在tables标签里面添加Item

       ```xml
       <tb_friend>
           data_type = 1
           section_factor = 1
           cols = uid|friend_uid|relationship,
       </tb_friend>
       ```

3. 修改`dbagentserver/config/DB.conf`

   31. 在table标签里面添加Item

       ```xml
       <tb_friend>
           data_type = 1
           section_factor = 1
           db_name = hp_friend
           table_num = 1			
       </tb_friend>
       ```

   32. 在database标签里面添加Item

       ```xml
       <hp_friend>
           db_group = db_hp_friend
       </hp_friend>
       ```

   33. 在cluster里面添加Item

       ```
       db_hp_friend = db_hp_friend_1
       ```

   34. 在db_group里面添加Item

       ```xml
       <db_hp_friend_1>
           master_host = 192.168.0.250
           slave_host = 192.168.0.250
           port = 3306
           user = tars
           password = tars2015
           charset = utf8
           dbname = hp_friend
       </db_hp_friend_1>
       ```


# Log 日志

路径

```shell
/usr/local/app/tars/app_log/XGame/FriendsServer
```



# 服务路径

+ 可执行文件路径

  ```
  /usr/local/app/tars/tarsnode/data/XGame.FriendsServer/bin
  ```

+ 配置文件路径

  ```
  /usr/local/app/tars/tarsnode/data/XGame.FriendsServer/bin
  ```

+ 启动脚本路径

  ```
  /usr/local/app/tars/tarsnode/data/XGame.FriendsServer/bin
  ```



# 编译相关命令

```shell
# 重新将*.tars生成*.h 并且将*.tars和生成的*.h 以及makefiele拷贝出去，在目标路径生成mk文件
make release

# 编译  不会影响/home/tarsproto/XGame/
make

# 打包 不会影响/home/tarsproto/XGame/
make tar
```



# 将tars文件生成*.h头文件

```
/usr/local/tars/cpp/tools/tars2cpp ./FriendsServant.tars
```



# 启动命令

```shell
gdbserver localhost:2334 ./DataProxyServer --config=/usr/local/app/tars/tarsnode/data/Debug.DataProxyServer/conf/Debug.DataProxyServer.config.conf
```



# 服务配置文件更改

![](img\微信截图_20190830114359.png)



# 读取数据

```c++
dataproxy::TReadDataReq dataReq;
dataReq.keyName = I2S(E_REDIS_TYPE_LIST) + ":" + I2S(FRIEND_INFO) + ":" + L2S(req.uid);
dataReq.operateType = E_REDIS_READ;

dataReq.clusterInfo.busiType = E_PROPERTY;
dataReq.clusterInfo.frageFactorType = E_FRAGE_FACTOR_USER_ID;
dataReq.clusterInfo.frageFactor = req.uid;

vector<TField> fields;
TField tfield;
tfield.colName = "uid";
tfield.colType = BIGINT;
fields.push_back(tfield);

tfield.colName = "friend_uid";
tfield.colType = BIGINT;
fields.push_back(tfield);

tfield.colName = "relationship";
tfield.colType = INT;
fields.push_back(tfield);
dataReq.fields = fields;

TReadDataRsp dataRsp;
iRet = g_app.getOuterFactoryPtr()->getDataProxyServantPrx()->read(dataReq, dataRsp);
ROLLLOG_DEBUG << "get user auth info, iRet: " << iRet << ", dataRsp: " << printTars(dataRsp) << endl;
//请求异常或应答错误
if (iRet != 0 || dataRsp.iResult != 0)
{
    ROLLLOG_ERROR << "get user auth info err, iRet: " << iRet << ", iResult: " << dataRsp.iResult << endl;
    resp.resultCode = -2;
    return -2;
}
```



# 插入数据

```c++
dataproxy::TWriteDataReq wdataReq;
wdataReq.keyName = I2S(E_REDIS_TYPE_HASH) + ":" + I2S(FRIEND_INFO) + ":" + L2S(req.uid);;
wdataReq.operateType = E_REDIS_INSERT;

wdataReq.clusterInfo.busiType = E_PROPERTY;
wdataReq.clusterInfo.frageFactorType = E_FRAGE_FACTOR_USER_ID;
wdataReq.clusterInfo.frageFactor = req.uid;

vector<TField> fields;
fields.clear();

TField tfield;
tfield.colName = "uid";
tfield.colType = BIGINT;
tfield.colValue = L2S(req.uid);
fields.push_back(tfield);

tfield.colName = "friend_uid";
tfield.colType = BIGINT;
tfield.colValue = L2S(req.friend_uid);
fields.push_back(tfield);


tfield.colName = "relationship";
tfield.colType = INT;
tfield.colValue = I2S(2);
fields.push_back(tfield);

wdataReq.fields = fields;

TWriteDataRsp wdataRsp;
TWriteDataRsp dataRsp;
iRet = g_app.getOuterFactoryPtr()->getDataProxyServantPrx()->write(wdataReq, wdataRsp);
ROLLLOG_DEBUG << "set friend data, iRet: " << iRet << ", wdataRsp: " << printTars(wdataRsp) << endl;
//请求异常或应答错误
if (iRet != 0 || dataRsp.iResult != 0)
{
    ROLLLOG_ERROR << "save deviceno map err, iRet: " << iRet << ", iResult: " << dataRsp.iResult << endl;
    return -6;
}
```



# 常用函数

+ 日志

  ```c++
  #define ROLLLOG_DEBUG (ROLLLOG(debug)) 		//DEBUG
  #define ROLLLOG_INFO (ROLLLOG(info))   		//INFO
  #define ROLLLOG_WARN (ROLLLOG(warn))  		//WARN
  #define ROLLLOG_ERROR (ROLLLOG(error)) 		//ERROR
  
  #define FUNC_ENTRY(in) (ROLLLOG(debug) << ">>>> Enter " << __FUNCTION__ << "() in(" << in << ")" << endl)
  #define FUNC_EXIT(out, ret) (ROLLLOG(debug) << "<<<< Exit " << __FUNCTION__ << "() out[" << out << "], ret = " << ret << endl)
  #define FDLOG_CONFIG_INFO (FDLOG("config_info") << "|") //输出到指定文件
  ```




# 与客户端调协议

1. 在CommonStruct.proto里面的ActionName里面添加子命令字
2. 在XGameComm.proto里面的SERVICE_TYPE里面添加服务类型，让route来转发
3. 在服务里面实现onRequest的接口，对不同子命令字进行响应的处理！！！



# protocols 工程

第一次make会提示`No rule to make target CommonCode.pb.o`,再make一次即可，然后用make release1拷贝至指定目录





# 日志

```shell
# 聊天
vim ~/log/XGame/FriendsServer/XGame.FriendsServer.log
```





# 推送消息代码

```c++
template<typename T> int ChatServantImp::toClientPb(const XGameComm::TPackage& tPackage, const std::string& sCurServrantAddr, XGameProto::ActionName actionName, const T& t)
{
	XGameComm::TPackage rsp;

	rsp.set_iversion(tPackage.iversion());
	XGameComm::TUid* ptuid = rsp.mutable_stuid();
	ptuid->set_luid(tPackage.stuid().luid());
	rsp.set_igameid(tPackage.igameid());
	rsp.set_sroomid(tPackage.sroomid());
	rsp.set_iroomserverid(tPackage.iroomserverid());
	rsp.set_isequence(tPackage.isequence());
	rsp.set_iflag(tPackage.iflag());

	XGameComm::TMsgHead* mh = rsp.add_vecmsghead();
	//mh->set_nmsgid(XGameComm::Eum_Comm_Msgid::E_MSGID_LOGIN_SERVER_RESP);
	mh->set_nmsgid(actionName);
	mh->set_nmsgtype(XGameComm::MSGTYPE::MSGTYPE_RESPONSE);//此处根据实际情况更改
	mh->set_servicetype(XGameComm::SERVICE_TYPE::SERVICE_TYPE_CHAT);//此处根据实际情况更改

	//XGameProto::CommonRespHead commonRespHead;
	//commonRespHead.set_resultcode(0);
	//commonRespHead.set_actionname(actionName);
	//commonRespHead.set_respbodybytes(pbToString(t));

	rsp.add_vecmsgdata(pbToString(t));

	ROLLLOG_DEBUG << "toclient pb: " << logPb(rsp) << endl;

	JFGame::PushPrx pPushPrx = Application::getCommunicator()->stringToProxy<JFGame::PushPrx>(sCurServrantAddr);
	pPushPrx->async_doPushBuf(NULL, tPackage.stuid().luid(), pbToString(rsp));
	
	return 0;
}
```

